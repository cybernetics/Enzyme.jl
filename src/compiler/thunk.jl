struct Thunk{f, RT, TT}
    ptr::Ptr{Cvoid}
end

@generated function (thunk::Thunk{f, RT, TT})(args...) where {f, RT, TT}
    _args = (:(args[$i]) for i in 1:length(args))
    quote
        ccall(thunk.ptr, $RT, ($(args...),), $(_args...))
    end
end

function thunk(f::F,tt::TT=Tuple{}) where
              {F<:Core.Function, TT<:Type}
    _tt = (tt.parameters...,)
    primal_tt = map(eltype, _tt)
    name = "primal" 

    # CTX, f are ghosts
    overdub_tt = Tuple{typeof(Compiler.CTX), F, primal_tt...}
    rt = Core.Compiler.return_type(Cassette.overdub, overdub_tt)
    # can't return array since that's complicated.
    @assert rt<:Union{AbstractFloat, Nothing}

    source = FunctionSpec(Cassette.overdub, overdub_tt, #=kernel=# false, name)
    GPUCompiler.cached_compilation(_thunk, source, f=f, rt=rt, tt=_tt)::Thunk{F,rt,tt}
end

# actual compilation
function _thunk(source::FunctionSpec; f, rt, tt)
    target = Compiler.EnzymeTarget()
    params = Compiler.EnzymeCompilerParams()
    job    = Compiler.CompilerJob(target, source, params)

    # Codegen the primal function and all its dependency in one module
    mod, primalf = Compiler.codegen(:llvm, job, optimize=false, #= validate=false =#)

    # Build the wrapper function
    ctx     = context(mod)
    rettype = convert(LLVMType, rt)

    params = parameters(primalf)
    adjoint_tt = LLVMType[]
    for (i, T) in enumerate(tt)
        llvmT = llvmtype(params[i])
        push!(adjoint_tt, llvmT)
        if T <: Duplicated 
            push!(adjoint_tt, llvmT)
        end
    end

    # create a wrapper Function that we will inline into the llvmcall
    # generated by `call_function` in `autodiff`
    llvmf = LLVM.Function(mod, "enzyme_entry", LLVM.FunctionType(rettype, adjoint_tt))
    push!(function_attributes(llvmf), EnumAttribute("alwaysinline", 0, ctx))

    # Create the FunctionType and funtion decleration for the intrinsic
    pt       = LLVM.PointerType(LLVM.Int8Type(ctx))
    ftd      = LLVM.FunctionType(rettype, LLVMType[pt])
    autodiff = LLVM.Function(mod, string("__enzyme_autodiff.", rt), ftd)

    params = LLVM.Value[]
    llvm_params = parameters(llvmf)
    i = 1
    for T in tt
        if T <: Const
            push!(params, MDString("diffe_const"))
        elseif T <: Active
            push!(params, MDString("diffe_out"))
        elseif T <: Duplicated
            push!(params, MDString("diffe_dup"))
            push!(params, llvm_params[i])
            i += 1
        elseif T <: DuplicatedNoNeed
            push!(params, MDString("diffe_dupnoneed"))
            push!(params, llvm_params[i])
            i += 1
        else
            @assert("illegal annotation type")
        end
        push!(params, llvm_params[i])
        i += 1
    end

    Builder(ctx) do builder
        entry = BasicBlock(llvmf, "entry", ctx)
        position!(builder, entry)

        tc = bitcast!(builder, primalf,  pt)
        pushfirst!(params, tc)

        val = call!(builder, autodiff, params)

        ret!(builder, val)
    end

    LLVM.strip_debuginfo!(mod)
    
    # Run pipeline and Enzyme pass
    optimize!(mod, llvmf)

    # Now invoke the JIT
    jitted_mod = compile(jit[], mod)
    ptr = addressin(jit[], jitted_mod, "enzyme_entry")


    return Thunk{typeof(f), rt, Tuple{tt...}}(ptr)
end


